#!/usr/bin/env python3

import os
import sys
import optparse


# We need to import some python modules from the $SUMO_HOME/tools directory.
if 'SUMO_HOME' in os.environ:
    tools = os.path.join(os.environ['SUMO_HOME'], 'tools')
    sys.path.append(tools)
else:
    sys.exit('Please declare environment variable: "SUMO_HOME"')
sys.path.append("../globalConfigs")
sys.path.append("../../utils")

# Checks for the binary in environment variables.
import traci
from datetime import datetime
from constants import *
from simulation import *
from processing import *


def get_options():
    opt_parser = optparse.OptionParser()
    opt_parser.add_option("--nogui", action="store_true",
                          default=False, help="run the commandline version of sumo")
    options, args = opt_parser.parse_args()
    return options


def printTempFilesLocations():
    """Prints all of the temporary reports generated by the last-run simulation."""
    printSavedLocation("reports/temp_fcd.xml")
    printSavedLocation("reports/temp_inductionloops.xml")
    printSavedLocation("reports/temp_netstate-dump.xml")
    printSavedLocation("reports/temp_tripinfo.xml")
    printSavedLocation("reports/temp_ssm.xml")
    printSavedLocation("reports/temp_collisions.xml")


def printSavedLocation(filePath: str):
    """Prints the path of a file.

        Args:
            filePath (str): The path to print.
    """
    print("\tSaved data to: %s" % filePath)


def processData(timestamp):
    """Parses all the relevant simulation data into pd.Dataframes."""
    print("Processing data. Please wait...")
    printTempFilesLocations()
    print("Processing done.")


# def test():
    # "traci.vehicle.subscribeContext('125','CMD_GET_VEHICLE_VARIABLE',10000);
    # traci.vehicle.addSubscriptionFilterLeadFollow(0);
    # [M] = traci.vehicle.getContextSubscriptionResults('1100');
    #     I think the default arguments for subscribeContext are invalid in the matlab client.
    # You should get better results if you set subscriptionBegin=0 subscriptionEnd=86400

    # the domain refers to the type of object you wish to retrieve
    # CMD_GET_VEHICLE_VARIABLE to retrieve vehicles
    # CMD_GET_PERSON_VARIABLE to retrieve persons

    #     traci.vehicle.subscribeContext('1100',
    # traci.constants.CMD_GET_VEHICLE_VARIABLE,250 {traci.constants.VAR_IDList,
    # traci.constants.VAR_SPEED});
    # traci.vehicle.addSubscriptionFilterLeadFollow('1');
    # [M] = traci.vehicle.getContextSubscriptionResults('1100');
    # I am just getting the count of vehicles as output.
    # How to get the list of vehicle IDs?

    # leave out constants.VAR_IDList. the surrounding vehicle ids are part of the result object implicitly.
    # varIDs is a list of variables that you wish to retrieve.

    # vehicleIds = list(traci.vehicle.getIDList())
    # traci.vehicle.addSubscriptionFilterLateralDistance(20)


def rerouteConnectedCivilians():
    print(
        f"\n\n\n================================================\nNEW STEP ( T+{getTime()} )\n================================================\n")

    overlappingRoutes = findOverlappingRoutes()

    # If there are no overlapping routes between civilian and ER vehicles,
    # then there is no need to modify the routes of any vehicle.
    if len(overlappingRoutes) == 0:
        return

    # Establish detours for each vehicle that conflicts with an ER's route.
    for pair in overlappingRoutes:
        civilianArrivalTimes = getArrivalTimes(pair['civilian'])
        emergencyArrivalTimes = getArrivalTimes(pair['ER'])

        # The edges where both vehicles arrival at a time less than the time-headway threshold.
        conflictEdges = findArrivalTimeConflicts(
            civilianArrivalTimes, emergencyArrivalTimes)
        print(
            f"\nTime conflicts between veh ( {pair['civilian']} ) and ( {pair['ER']} )\n\t{conflictEdges}")

        if len(conflictEdges) > 0:
            # Decrease the desirability for the conflicting edges for the civilian.
            civVehId = pair['civilian']

            setTravelTime(civVehId, conflictEdges[0])

            # Recalculate the vehicle's route given the changes to the edge weights.
            traci.vehicle.rerouteTraveltime(civVehId)


def computeRoute(vehID):
    currentRoute = getRoute(vehID)
    print("Current route =", currentRoute)


def runSimulation(maxSteps):
    """Runs the simulation and saves the results in timestamped CSV files."""
    step = 0

    # Check binary.
    options = get_options()
    if options.nogui:
        sumoBinary = SUMO
    else:
        sumoBinary = SUMOGUI

    # TraCI starts sumo as a subprocess and then this script connects and runs.
    traci.start([sumoBinary,
                 "-c", "configs/thesis.sumocfg",
                 "--tripinfo-output", "reports/temp_tripinfo.xml",
                 "--lateral-resolution", "3",
                 "--collision-output", "reports/temp_collisions.xml",
                 "--collision.stoptime", "600",
                 ])

    print("Running simulation. Please wait...")
    while getCarCount() > 0 and step < maxSteps:
        # Contains TraCI control loop.
        step += 1
        nextStep()

        # Rerouting is only necessary if there are ERs actively
        # in the simulation.
        # It takes a few seconds for a newly rerouted vehicle to get off the path of an ER, so only check
        # every 10 seconds.
        if step % 5 == 0:
            # Reset the detours.
            print("Resetting the adapted travel times")
            for veh in getConnCivilians():
                resetTravelTime(veh['id'])

            if anyActiveEV() is True:
                rerouteConnectedCivilians()

    # Close TraCI.
    traci.close()
    print("Simulation over.")


def main():
    timestamp = datetime.now().strftime('%Y%m%d_%H-%M-%S')
    MAX_STEPS = HOUR * 3  # {seconds}

    # Run the simulation.
    runSimulation(MAX_STEPS)

    # Process and export the data.
    processData(timestamp)


if __name__ == "__main__":
    main()
