import sys
sys.path.append("../../")
sys.path.append("../../utils")
from utils import rsri
import xml.etree.ElementTree as et
from datetime import datetime
import pandas as pd
from inputOutput import exportCSV


def parseConflictChild(node):
    time = node.get('time')
    position = node.get('position')
    type = node.get('type')
    value = node.get('value')
    return {"time (sec)": time, "position (m)": position, "type": type, "value": value}


def parseMinTTC():
    """Parses the minTTC from the temp SSM XML file generated by SUMO, and exports the
        the results to a permenant CSV file.
    """
    xmlFile = "reports/temp_ssm.xml"
    csvFilename = 'reports/%s_minTTC.csv' % (timestamp)

    xtree = et.parse(xmlFile)
    xroot = xtree.getroot()
    columns = ["time (sec)",
               "type",
               "lane",
               "pos (m)",
               "collider",
               "victim",
               "colliderType",
               "victimType",
               "colliderSpeed (m/s)",
               "victimSpeed (m/s)"]
    rows = [columns]

    xtree = et.parse(xmlFile)
    xroot = xtree.getroot()
    for conflict in xroot.findall('conflict'):
        begin = conflict.get('begin')
        end = conflict.get('end')
        ego = conflict.get('ego')
        foe = conflict.get('foe')
        minTTC = parseConflictChild(conflict.find('minTTC'))
        maxDRAC = parseConflictChild(conflict.find('maxDRAC'))
        pet = parseConflictChild(conflict.find('PET'))
        conflictDict = {'begin (sec)': begin, 'end (sec)': end, 'ego (veh)': ego,
                        'foe (veh)': foe, 'minTTC': minTTC, 'maxDRAC': maxDRAC, 'PET': pet}
        rows.append(conflictDict)

    return rows


def parseCollisions(timestamp):
    """Parses the temp collisions XML file generated by SUMO, and exports the
        the results to a permenant CSV file.
    """
    xmlFilename = "reports/temp_collisions.xml"
    csvFilename = 'reports/%s_collisions.csv' % (timestamp)
    columns = ["time (sec)",
               "type",
               "lane",
               "pos (m)",
               "collider",
               "victim",
               "colliderType",
               "victimType",
               "colliderSpeed (m/s)",
               "victimSpeed (m/s)"]
    rows = [columns]

    xtree = et.parse(xmlFilename)
    xroot = xtree.getroot()
    for node in xroot:
        time = node.get('time')
        type = node.get('type')
        lane = node.get('lane')
        pos = node.get('pos')
        collider = node.get('collider')
        victim = node.get('victim')
        colliderType = node.get('colliderType')
        victimType = node.get('victimType')
        colliderSpeed = node.get('colliderSpeed')
        victimSpeed = node.get('victimSpeed')

        rows.append([time,
                     type,
                     lane,
                     pos,
                     collider,
                     victim,
                     colliderType,
                     victimType,
                     colliderSpeed,
                     victimSpeed
                     ])
    if len(rows) <= 1:
        print("\tWarning: No collisions to parse.")
    else:
        exportCSV(csvFilename, rows)


def parseInductionLoops(timestamp):
    """Parses the temp inductionloops XML file generated by SUMO, and exports the
        the results to a permenant CSV file.
    """
    xmlFilename = "reports/temp_inductionloops.xml"
    csvFilename = 'reports/%s_inductionloops.csv' % (timestamp)
    columns = ["loop ID", "begin (sec)", "end (sec)", "nVehContrib",
               "flow (veh/hr)", "occupancy (%)", "speed (m/s)", "nVehEntered"]
    rows = [columns]

    xtree = et.parse(xmlFilename)
    xroot = xtree.getroot()
    for node in xroot:
        begin = node.attrib.get("begin")
        end = node.attrib.get("end")
        id = node.attrib.get("id")
        nVehContrib = node.attrib.get("nVehContrib")
        flow = node.attrib.get("flow")
        occupancy = node.attrib.get("occupancy")
        speed = node.attrib.get("speed")
        nVehEntered = node.attrib.get("nVehEntered")

        rows.append([id, begin, end, nVehContrib, flow,
                     occupancy, speed, nVehEntered])

    if len(rows) <= 1:
        print("\tWarning: No induction loops to parse.")
    else:
        exportCSV(csvFilename, rows)


def computeSafetyDistance():
    # Velocities of both vehicles.
    velocity_1 = 16.67
    velocity_2 = 15.23

    # The time needed to begin braking.
    reactionTime = 1

    # Maximum decelerations for both vehicles.
    deceleration_1 = 9
    deceleration_2 = 9

    # Desired distance between vehicles when at a complete stop.
    desiredParkingDistance = 2.5  # meters

    # Distance traveled by vehicle-1 after `reactionTime` seconds.
    distance = velocity_1 * reactionTime

    # Distances traveled after applying brakes.
    stoppingDistance_1 = (velocity_1**2) / (2 * deceleration_1)
    stoppingDistance_2 = (velocity_2**2) / (2 * deceleration_2)
    # Difference in stopping distances between both vehicles.
    stoppingDiffDistance = stoppingDistance_1 - stoppingDistance_2

    safetyDistance = distance + stoppingDiffDistance + desiredParkingDistance
    return safetyDistance


if __name__ == "__main__":
    timestamp = datetime.now().strftime('%Y%m%d_%H-%M-%S')
    csvSSMFilename = 'reports/%s_ssm.csv' % (timestamp)
    # conflicts = parseConflicts()
    parseCollisions(timestamp)
    parseInductionLoops(timestamp)
    vh = computeSafetyDistance()
    print("Desired safety distance =", vh)
    # print(pd.DataFrame(conflicts))
    # rsri.main(filename="reports/20211114_16-33-28_inductionloops.csv")
